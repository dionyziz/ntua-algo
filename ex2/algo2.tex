\documentclass[11pt,a4paper]{book}
\usepackage[english,greek]{babel}
\usepackage[utf8x]{inputenc}
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\usepackage{amssymb,latexsym,amsmath,ucs,amsthm,setspace,graphicx,fancyvrb,float}
\usepackage{hyperref}
\newtheorem*{lemma}{Λήμμα}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\newcommand{\defeq}{\overset{\underset{\mathrm{def}}{}}{=}}
\makeatletter
\def\imod#1{\allowbreak\mkern10mu({\operator@font mod}\,\,#1)}
\makeatother
\raggedbottom
\begin{document}

\begin{titlepage}
\begin{center}

\includegraphics[width=0.15\textwidth]{Pyrforos3.png}\\[1cm]
\textsc{\LARGE Εθνικό Μετσόβιο Πολυτεχνείο}\\[1.5cm]

\Large{ 2η Γραπτή Άσκηση }\\[0.5cm]

% Title
\begin{doublespace}
\HRule \\[0.4cm]
{\huge \bfseries
Αλγόριθμοι \& Πολυπλοκότητα
}\\[0.4cm]
\end{doublespace}

\HRule \\[1.5cm]

\begin{minipage}{0.4\textwidth}
\begin{flushleft} \large
\emph{Σπουδαστής:} \\
Διονύσης \textsc{Ζήνδρος} (06601)\\
\textlatin{\textless dionyziz@gmail.com\textgreater}
\end{flushleft}
\end{minipage}
\begin{minipage}{0.4\textwidth}
\begin{flushright} \large
\emph{Διδάσκοντες:} \\
Στάθης \textsc{Ζάχος}\\
Δημήτρης \textsc{Φωτάκης}
\end{flushright}
\end{minipage}

\vfill

{\large 31 Δεκεμβρίου 2011}
\end{center}
\end{titlepage}

\section*{Άσκηση 1}

Ο αλγόριθμος που χρησιμοποιούμε είναι άπληστος. Ταξινομούμε τα διαστήματα σε αύξουσα σειρά σύμφωνα με το χρόνο τερματισμού $f_i$. Κατά τη διάρκεια του αλγορίθμου, χρωματίζουμε όσα διαστήματα έχουμε, με κάποιον τρόπο, επικαλύψει. Θεωρούμε ότι αρχικά κανένα διάστημα δεν είναι χρωματισμένο. Επιλέγουμε κάθε φορά να καλύψουμε το διάστημα που βρίσκεται αριστερότερα, σύμφωνα με την ταξινόμησή μας, από όλα τα διαστήματα που δεν έχουμε χρωματίσει ακόμη, αρχικά δηλαδή το αριστερότερο από όλα. Στη συνέχεια, επιλέγουμε από όλα τα διαστήματα που το επικαλύπτουν εκείνο που βρίσκεται δεξιότερα έτσι ώστε να πετύχουμε το μέγιστο δυνατό εύρος επικάλυψης. Αυτό το διάστημα επιλέγεται αμετάκλητα ως μέρος της απάντησής μας.

Αφότου κάνουμε την επιλογή αυτού διαστήματος, χρωματίζουμε όλα τα διαστήματα που αυτό επικαλύπτει, και συνεχίζουμε την ίδια διαδικασία.

\selectlanguage{english}
\begin{algorithm}[H]
\caption{\textgreek{Άσκηση 1}}
\begin{algorithmic}[1]
\Procedure{Covers}{$a, b$}
	\State \Return $a.s \leq b.s \land a.f > b.f \lor b.s \leq a.s \land b.f > a.f$
\EndProcedure

\Procedure{Intervals}{$s, f, n$}
	\For {$i \gets 1$ to $n$}
		\State {$A[ i ].s \gets s_i$}
		\State {$A[ i ].f \gets f_i$}
		\State {$A[ i ].covered \gets \bot$}
	\EndFor
	\State $A \gets $ sort $A$ by $f$
	\State $cost \gets 0$
	\For {$i \gets 1$ to $n$}
		\If {$\lnot A[ i ].covered$}
			\For {$j \gets n$ downto $1$}
				\If {$\Call{Covers}{A[ i ], A[ j ]}$}
					\State $cost \gets cost + 1$
					\For {$k \gets 1$ to $n$}
						\If {$\Call{Covers}{A[ j ], A[ k ]}$}
							\State $A[ k ].covered \gets \top$
						\EndIf
					\EndFor
					\State $break$
				\EndIf
			\EndFor
		\EndIf
	\EndFor
	\State \Return $cost$
\EndProcedure
\end{algorithmic}
\end{algorithm}
\selectlanguage{greek}

Ο αλγόριθμος θα είναι $O( n^2 )$ καθώς περνάμε από $n$ διαστήματα για κάθε ένα από τα οποία βρίσκουμε το τελευταίο με το οποίο επικαλύπτεται σε $O( n )$ και στη συνέχεια, σε $O( n )$, χρωματίζουμε τα το πολύ $n$ διαστήματα που η επιλογή μας επικαλύπτει.

\section*{Άσκηση 2}
Διασχίζουμε όλα τα διαστήματα με τη σειρά από εκείνο με το μικρότερο όριο ταχύτητας έως εκείνο με το μεγαλύτερο όριο ταχύτητας προσθέτοντας κάθε φορά όλο το χρόνο που μας απομένει στο αντίστοιχο διάστημα.

\begin{lemma}
Η λύση που επιλέγει τα διαστήματα σε αύξουσα σειρά με βάση το όριο ταχύτητας είναι ορθή.
\end{lemma}
\begin{proof}

\hspace*{\fill} \\

{\bf Επιχείρημα διαχωρισμού}: Το πρόβλημα παραμένει ισοδύναμο αν <<σπάσουμε>> οποιοδήποτε διάστημα του δρόμου σε μικρότερα.

\hspace*{\fill} \\

Αν επιλέξουμε τα διαστήματα σε αύξουσα σειρά με βάση το όριο ταχύτητας και κατανείμουμε όσο χρόνο έχουμε διαθέσιμο όσο μπορούμε, ενδέχεται να υπάρχει ένα τελευταίο διάστημα στο οποίο θα πρέπει να κατανείμουμε το χρόνο που μας απομένει σε μέρος του. Αν υπάρχει, χρησιμοποιώντας το επιχείρημα διαχωρισμού, επιλέγουμε να <<σπάσουμε>> το διάστημα αυτό σε δύο τμήματα έτσι ώστε ο χρόνος που απομένει να μπορεί να κατανεμηθεί ολόκληρος στο πρώτο μισό, έτσι ώστε να μην υπάρχει άλλος χρόνος για το δεύτερο μισό. Αυτό οδηγεί σε ένα ισοδύναμο πρόβλημα και διευκολύνει την απόδειξη.

Έστω ότι η ορθή λύση, αν είχαμε μόνο τα πρώτα $i$ διαστήματα με το μικρότερο όριο ταχύτητας στη διάθεσή μας, έχει κόστος $J'[ i ]$, δηλαδή συνολικό χρόνο που χρειάζεται ο μοτοσικλετιστής για να τα διασχίσει όλα. Έστω ότι η λύση μας που περιλαμβάνει όσα διαστήματα μπορεί με τη σειρά από το μικρότερο προς το μεγαλύτερο έχει κόστος $J[ i ]$. Θα δείξουμε ότι τα κόστη αυτά ταυτίζονται.

Έστω $K[ i ]$ ο δείκτης του $i$-οστού διαστήματος σε αύξουσα σειρά ορίου ταχύτητος.

Θα είναι:
\[
J[ 0 ] = J'[ 0 ]
\]

Έστω, τώρα ότι:
\[
\forall i < n: J[ i ] = J'[ i ]
\]

Υποθέτουμε τώρα ότι:
\[
\sum_{j=0}^i \frac{l_{K[ j ]}}{v + u_{K[ j ]}} \leq T
\]

Δηλαδή ότι απομένει ακόμη χρόνος υπέρβασης ορίου ταχύτητας. Τότε επιλέγουμε να συμπεριλάβουμε ολόκληρο το $i$-οστό τμήμα. Αυτό μπορεί να συμπεριληφθεί ολόκληρο λόγω του επιχειρήματος διαχωρισμού διαστημάτων. Το να συμπεριλάβουμε το συγκεκριμένο τμήμα οδηγεί σε βέλτιστη λύση, διότι αν δεν το είχαμε συμπεριλάβει, θα είχαμε κάποιο τμήμα χρόνου υπέρβασης ορίου ταχύτητας ανεκμετάλλευτο το οποίο θα μπορούσαμε να είχαμε εκμεταλλευτεί. Αντίστοιχα, η λύση για τα πρώτα $i$ τμήματα θα πρέπει να περιλαμβάνει τη λύση για τα $i - 1$ τμήματα, καθώς οποιαδήποτε άλλη λύση για $i - 1$ τμήματα αφήνει ένα τμήμα χρόνου ανεκμετάλλευτο.

Συνεπώς:
\[
J[ i ] = J'[ i ]
\]

Έστω τώρα ότι, αντίθετα, είναι:
\[
\sum_{j=0}^{i} \frac{l_{K[ j ]}}{v + u_{K[ j ]}} > T
\]

Τότε για την $J$ λύση θα έχουμε ήδη αξιοποιήσει όλο το διαθέσιμο χρόνο υπέρβασης. Εξετάζουμε τώρα αν το $i$-οστό τμήμα θα συμπεριληφθεί. Η λύση $J$ δεν θα συμπεριλάβει το $i$-οστό τμήμα. Θα δείξουμε ότι ούτε η $J'$ θα το συμπεριλαμβάνει. Έστω, τώρα, ότι η λύση $J'[ i ]$ επιλέγει να υπερβεί το όριο ταχύτητας σε ένα διαφορετικό σύνολο από τα $i - 1$ από την $J[ i ]$ έτσι ώστε ο χρόνος διάσχισης να είναι $L > J'[ i - 1 ]$ και να απομένει κάποιος χρόνος κατανομής για το $i$-οστό τμήμα. Τότε ο χρόνος αυτός θα πρέπει να έχει αφαιρεθεί από ένα τμήμα από τα πρώτα $i - 1$ τμήματα. Λόγω του επιχειρήματος διαχωρισμού διαστημάτων μπορούμε να θεωρήσουμε ότι η ανταλλαγή αφορά ένα ολόκληρο διάστημα από τα $i - 1$ διαστήματα και χρησιμοποιείται για να αντικαταστήσουμε ολόκληρο το $i$-οστό διάστημα. Έστω ότι το $i$-οστό διάστημα επιλέγεται για υπέρβαση ταχύτητας αντί του $j$-οστού διαστήματος με $j < i$. Τότε θα είναι λόγω του επιχειρήματος διαχωρισμού:

\[
\frac{l_{K[ j ]}}{v + u_{K[ j ]}} = \frac{l_{K[ i ]}}{v + u_{K[ i ]}}\\
\]

Και έτσι λόγω της διάταξης έχουμε:

\begin{align*}
{u_{K[ i ]}} & > {u_{K[ j ]}} \\
\Rightarrow \frac{l_{K[ i ]}}{u_{K[ i ]}} & < \frac{l_{K[ j ]}}{u_{K[ j ]}} \\
\Rightarrow \frac{l_{K[ i ]}}{u_{K[ i ]}} - \frac{l_{K[ i ]}}{v + u_{K[ i ]}} & < \frac{l_{K[ j ]}}{u_{K[ j ]}} - \frac{l_{K[ j ]}}{v + u_{K[ j ]}}
\end{align*}

Από αυτό καταλήγουμε στο ότι η επιλογή του $i$-οστού διαστήματος είναι πιο επιθυμητή από την επιλογή του $j$-οστού διαστήματος και έτσι η λύση $J'[ i - 1 ]$ αποτελεί μέρος της λύσης $J'[ i ]$. Έτσι έχουμε αρχή της βελτιστότητας στο πρόβλημα. Συνεπώς προκύπτει ότι:

\[
J[ i ] = J'[ i ]
\]

Χρησιμοποιώντας την μαθηματική επαγωγή, αυτό ολοκληρώνει την απόδειξη.
\end{proof}

\selectlanguage{english}
\begin{algorithm}[H]
\caption{\textgreek{Άσκηση 2}}
\begin{algorithmic}[1]
\Procedure{Motorcycle}{$l, u, n, v, T$}
	\For {$i \gets 1$ to $n$}
		\State $A[ i ].u \gets u[ i ]$
		\State $A[ i ].l \gets l[ i ]$
		\State $A[ i ].i \gets i$
	\EndFor
	\State $A \gets $ sort $A$ by $u$
	\State $S \gets \emptyset$
	\For {$i \gets 1$ to $n$}
		\State $speed \gets v + A[ i ].u$
		\State $t \gets \frac{A[ i ].l}{speed}$
		\If {$T > t$}
			\State $S \gets S \cup \{ ( A[ i ].i, A[ i ].l ) \}$
			\State $T \gets T - t$
		\Else
			\State $S \gets S \cup \{ ( A[ i ].i, T * speed ) \}$
			\State $break$
		\EndIf
	\EndFor
	\State \Return $S$
\EndProcedure
\end{algorithmic}
\end{algorithm}
\selectlanguage{greek}

Ο αλγόριθμος θα είναι $\Theta( n \log{n} )$ καθώς περιλαμβάνει μία ταξινόμηση, ενώ η επόμενη επανάληψη είναι γραμμική.

Ας εξετάσουμε τώρα την περίπτωση που η παραβίαση του ορίου ταχύτητας γίνεται κατά έναν παράγοντα $\alpha$.

\begin{lemma}
Αν ο μοτοσικλετιστής έχει τη δυνατότητα να παραβιάσει τα όρια ταχύτητας κατά έναν παράγοντα $\alpha$, τότε η επιλογή των διαστημάτων είναι αδιάφορη.
\end{lemma}
\begin{proof}
Έστω ότι ο μοτοσικλετιστής θέλει να επιλέξει αν θα αφιερώσει χρόνο $t$ για να παραβιάσει το όριο ταχύτητας στο τμήμα $i$ ή στο τμήμα $j$. Τότε ο χρόνος που θα γλυτώσει θα είναι ανεξάρτητος αυτής της επιλογής.

Πράγματι, έστω ότι επιλέγει να αφιερώσει χρόνο $t$ στο διάστημα $i$ και έστω, χωρίς βλάβη της γενικότητας, ότι $t \leq l_i / u_i$. Τότε έστω $t'$ ο χρόνος κατά τον οποίο ο μοτοσικλετιστής διασχίζει ένα τμήμα του διαστήματος στην κανονική του ταχύτητα. Θα έχουμε:

\begin{align*}
 l &= aut + ut'\\
t' &= \frac{l - aut}{u}\\
   &= \frac{l}{u} - at\\
t + t' &= t + \frac{l}{u} - at\\
\frac{l}{u} - (t + t') &= at - t
\end{align*}

Αυτός είναι και ο χρόνος που θα έχει κερδίσει. Πράγματι, ο χρόνος αυτός είναι ανεξάρτητος της επιλογής $i$.
\end{proof}

\section*{Άσκηση 3}
\subsection*{α)}
Ένα παράδειγμα για το οποίο ο άπληστος αλγόριθμος δεν δίνει το βέλτιστο αποτέλεσμα είναι το εξής:

\vspace{3mm}
\begin{doublespace}
\begin{tabular}{|c|c|c|}
	\hline
	0    & 4999 & 0    \\ \hline
	4999 & 5000 & 4999 \\ \hline
	0    & 4999 & 0    \\ \hline
	0    &    0 & 0    \\ \hline
\end{tabular}
\end{doublespace}
\vspace{3mm}

Ενώ ο άπληστος αλγόριθμος θα επιλέξει να τοποθετήσει ένα βότσαλο
στο κουτί με αξία 5000, η βέλτιστη λύση επιτυγχάνεται επιλέγοντας
τα 4 κουτάκια που είναι γείτονές του και δίνουν συνολική αξία 19,996.

Οι χειρότερες περιπτώσεις για τον άπληστο αλγόριθμο είναι εκείνες που τον <εξαναγκάζουν> να κάνει μία τοπικά βέλτιστη επιλογή, όμως του στερούν μεγαλύτερο κέρδος συνολικά, όπως η παραπάνω. Τέτοιες περιπτώσεις περιλαμβάνουν ένα κεντρικό στοιχείο το οποίο έχει μία μεγάλη τιμή $M$ και γύρω του, κάθετα και οριζόντια, στοιχεία που έχουν επίσης μεγάλες τιμές, αλλά κατά κάποιο ε μικρότερες από $M$. Έτσι ο αλγόριθμος επιλέγει το $M$ αλλά αποκλείει την επιλογή 4 στοιχείων με συνολική αξία $4(M - \epsilon)$.

\vspace{3mm}
\begin{doublespace}
\begin{tabular}{|c|c|c|}
	\hline
	$0$            & $M - \epsilon$ & $0$            \\ \hline
	$M - \epsilon$ & $M$            & $M - \epsilon$ \\ \hline
	$0$            & $M - \epsilon$ & $0$            \\ \hline
	$0$            & $0$            & $0$            \\ \hline
\end{tabular}
\end{doublespace}
\vspace{3mm}

Έτσι, ο αλγόριθμος συγκεντρώνει πάντα περισσότερο από $20\%$ της συνολικής αξίας, δηλαδή $\frac{M}{4(M - \epsilon)}$. Αθροιστικά, αν υπάρχουν και άλλες τέτοιες εμφανίσεις του μοτίβου μέσα στα δεδομένα, ο αλγόριθμος και πάλι θα συγκεντρώσει το $20\%$. Διαφορετικά, ο αλγόριθμος ενδέχεται να συγκεντρώσει και μεγαλύτερα ποσά.

\subsection*{β)}
Η λύση δυναμικού προγραμματισμού εντοπίζει τη βέλτιστη διάταξη σε γραμμικό χρόνο διασχίζοντας τη σκακιέρα από τα αριστερά προς τα δεξιά.

Σε κάθε βήμα, όταν επεξεργαζόμαστε την $i$-οστή στήλη, αποθηκεύουμε το βέλτιστο ποσό $J[ i, \mu ]$ που μπορούμε να κερδίσουμε από το μέρος της σκακιέρας που αποτελείται από τις στήλες $1$ έως $i$ για κάθε πιθανό συνδυασμό βοτσάλων $\mu$ που μπορούμε να τοποθετήσουμε στην $i$-οστή στήλη. Έχοντας αυτά τα δεδομένα, ο υπολογισμός της βέλτιστης λύσης για την $(i + 1)$-οστή στήλη προκύπτει από την εξής αναδρομική σχέση:

\begin{align*}
	\Omega = \{ x \in 2^{\{1, 2, 3, 4\}}: \forall \alpha, \beta \in x: \alpha - 1 \neq \beta \}\\
	J[ i, \mu ] = \max\{J[ i - 1, \mu' ] + \sum_{q \in \mu}{C[ i, q ]}: \mu' \in \Omega \land \mu' \cap \mu = \emptyset\}
\end{align*}



\selectlanguage{english}
\begin{algorithm}[H]
\caption{\textgreek{Άσκηση 3β}}
\begin{algorithmic}[1]
\Procedure{Chess}{$C, n$}
	\State $M \gets \{ x \in 2^{\{1, 2, 3, 4\}}: \forall \alpha, \beta \in x: \alpha - 1 \neq \beta \}$
	\ForAll{$\mu \in M$}
		\State $J'[ \mu ] \gets 0$
	\EndFor
	\For{$i \gets 0$ to $n$}
		\For{$\mu \in M$}
			\State $J[ \mu ] \gets 0$
			\For{$\nu \in M$}
				\If {$\nu \cap \mu = \emptyset$}
					\State $J[ \mu ] \gets \max( J[ \mu ], J'[ \nu ] + \sum_{q \in \mu}{C[ i, q ]} )$
				\EndIf
			\EndFor
		\EndFor
		\State $J' \gets J$
	\EndFor
	\State \Return $\max( \{ J[ \mu ]: \mu \in M \} )$
\EndProcedure
\end{algorithmic}
\end{algorithm}
\selectlanguage{greek}

\section*{Άσκηση 4}
Σε κάθε βήμα $i$ του αλγορίθμου δυναμικού προγραμματισμού υπολογίζουμε το συνολικό κόστος $J[ i ]$ της βέλτιστης κατανομής λέξεων σε γραμμές μέχρι και την $i$-οστή λέξη. Στο τέλος του αλγορίθμου, το συνολικό κόστος δίνεται από το $J[ n ]$.

Η αρχή της βελτιστότητας που εμφανίζει το πρόβλημα είναι το γεγονός ότι όταν μία λύση είναι βέλτιστη, η κατανομή σε γραμμές όλων των λέξεων εκτός της τελευταίας γραμμής είναι βέλτιστη.

\begin{lemma}
Το βέλτιστο κόστος κατανομής όλων των λέξεων μέχρι και την $i$-οστή δίνεται από την αναδρομική σχέση:

\begin{align*}
J[ 0 ] &=& 0 \\
J[ i ] &=& \min_{1 \leq j \leq i}\{ J[ j - 1 ] + ( C + 1 - \sum_{k=j}^i(l[j] + 1) )^2 \}
\end{align*}
\end{lemma}
\begin{proof}
Έστω $J'$ το πραγματικό βέλτιστο κόστος κατανομής όλων των λέξεων μέχρι και την $i$-οστή λέξη. Θα δείξουμε ότι $J = J'$.

Για $i = 0$ το κείμενο δεν έχει γραμμές και συνεπώς $J[ 0 ] = J'[ 0 ]$.

Έστω $\forall n < i: J[ n ] = J'[ n ]$. Έστω ότι η βέλτιστη λύση για τις $i$ πρώτες λέξεις τοποθετεί τις λέξεις $j$ έως $i$ στην τελευταία γραμμή. Τότε το κόστος της τελευταίας γραμμής θα είναι:

\[
( C + 1 - \sum_{k=j}^i(l[j] + 1) )^2
\]

Έστω τώρα ότι η βέλτιστη λύση των πρώτων $i$ λέξεων περιλαμβάνει μία υποβέλτιστη λύση για την κατανομή των λέξεων $1$ έως $j - 1$ με κόστος $K > J[ j - 1 ]$. Τότε το συνολικό κόστος της κατανομής έως και την $i$-οστή λέξη θα είναι:

\[
J'[ i ] = K + ( C + 1 - \sum_{k=j}^i(l[j] + 1) )^2
\]

Όμως θα είναι $J'[ i ] > J[ i ]$, το οποίο είναι αντίφαση καθώς το κόστος $J'[ i ]$ είναι ελάχιστο. Συνεπώς $K = J[ j - 1 ]$. Καθώς το $J$ κρατά το ελάχιστο από όλα τα $j$, βελτιστοποιεί όσο αφορά το πλήθος των λέξεων που μπορεί να κρατήσει στην τελευταία γραμμή και άρα $J[ i ] = J'[ i ]$.

Χρησιμοποιώντας τη μαθηματική επαγωγή, αυτό ολοκληρώνει την απόδειξη.
\end{proof}

Έτσι επιτυγχάνουμε έναν πολυωνυμικό αλγόριθμο που για σταθερό $C$ τρέχει σε $\Theta( N )$ με μία σταθερά που είναι ανάλογη του μέσου πλήθος λέξεων ανά γραμμή. Ο λόγος που ο αλγόριθμος είναι γραμμικός είναι το γεγονός ότι σταματά αφότου η γραμμή που εξετάζει σε κάθε επανάληψη ξεπεράσει το μέγιστο επιτρεπόμενο όριο γραμμής.

\selectlanguage{english}
\begin{algorithm}[H]
\caption{\textgreek{Άσκηση 4}}
\begin{algorithmic}[1]
\Procedure{LineSplit}{$l, n, C$}
	\State $J[ 0 ] \gets 0$
	\For{$i \gets 1$ to $n$}
		\State $J[ i ] \gets \infty$
		\State $cost \gets C + 1$
		\For{$j \gets i$ downto $1$}
			\State $cost \gets cost - ( l[ j ] + 1 )$
			\If{$cost < 0$}
				\State $break$
			\EndIf
			\State $J[ i ] \gets \min( J[ i ], J[j - 1] + cost^2 )$
		\EndFor
	\EndFor
	\State \Return $J[ n ]$
\EndProcedure
\end{algorithmic}
\end{algorithm}
\selectlanguage{greek}

Ο αλγόριθμος εύκολα προσαρμόζεται έτσι ώστε για κάθε $i$ να αποθηκεύει και το δείκτη της λέξης που βρίσκεται τελευταία στην αμέσως προηγούμενη γραμμή όταν βελτιστοποιούμε για τις $i$ πρώτες λέξεις. Διασχίζοντας αυτό τον πίνακα, μπορούμε στη συνέχεια να οικοδομήσουμε την ομοιόμορφη κατανομή του όλου κειμένου σε γραμμές.

\section*{Άσκηση 5}
Χρησιμοποιούμε δυναμικό προγραμματισμό για να πετύχουμε πολυωνυμικό χρόνο εκτέλεσης. Αν $K$ είναι ο τελευταίος διακομιστής που δέχεται θετικό πλήθος αιτήσεων, η αρχή της βελτιστότητας του προβλήματος είναι το γεγονός ότι μία βέλτιστη λύση αν θεωρήσουμε ότι υπάρχουν μόνο οι διακομιστές $i$ έως $K$ της οποίας ο πρώτος διακομιστής που θα αποθηκεύσει το αρχείο είναι ο $j$ συμπεριλαμβάνει τη βέλτιστη λύση για την περίπτωση που υπάρχουν μόνο οι διακομιστές $j$ έως $K$.

Αυτό φαίνεται στην ακόλουθη αναδρομική σχέση. Με $JS[ i ]$ συμβολίζουμε το ελάχιστο κόστος που μπορούμε να πετύχουμε για το εύρος διακομιστών $i$ έως $K$ αν εγγυηθούμε ότι θα αποθηκεύσουμε στο διακομιστή $i$. Με $J[ i ]$ συμβολίζουμε το ελάχιστο κόστος που μπορούμε να πετύχουμε γενικά για το εύρος διακομιστών $i$ έως $K$.

\begin{lemma}
Το βέλτιστο κόστος αποθήκευσης για οποιοδήποτε εύρος διακομιστών $i$ έως $K$ δίνεται από την ακόλουθη αναδρομική σχέση:

\begin{align*}
	JS[ K ] = J[ K ] = c[ K ]\\
	JS[ i ] = J[ i + 1 ] + C[ i ]\\
	J[ i ] = \min_{i \leq j \leq K}\{ JS[ j ] + \sum_{l=i}^j{(j - l)B[l]} \}
\end{align*}
\end{lemma}
\begin{proof}
Έστω ότι $JS'$ και $J'$ τα πραγματικά ελάχιστα κόστη. Θα δείξουμε ότι $J = J'$ και $JS' = JS$.

Για $i = K$ η πρόταση ισχύει, αφού $b[ K ] \neq 0$ και άρα υποχρεωτικά θα αποθηκεύσουμε το αρχείο στο διακομιστή $K$.

Έστω ότι $\forall n: K \geq n > i \Rightarrow J[ n ] = J'[ n ] \land JS[ n ] = JS'[ n ]$.

Τώρα το κόστος αποθήκευσης για τον $i$-οστό διακομιστή σίγουρα θα συμπεριλαμβάνεται στο $JS'[ i ]$. Έστω, όμως, ότι οι διακομιστές στη συνέχεια δεν έχουν κατανεμηθεί βέλτιστα αλλα έχουν ένα κόστος $Q > J[ i + 1 ]$. Τότε θα είναι:

\begin{align*}
            & JS'[ i ] = C[ i ] + Q\\
\Rightarrow & JS'[ i ] > JS[ i ]
\end{align*}

Αυτό όμως είναι αδύνατο διότι η $JS'[ i ]$ είναι βέλτιστη. Άρα $Q = J[ i + 1 ]$ και $JS[ i ] = JS'[ i ]$.

Έστω τώρα ότι ο πρώτος διακομιστής που αποθηκεύει το αρχείο στη βέλτιστη λύση για τους διακομιστές $i$ έως $K$ είναι ο $j$-οστός. Τότε υποθέτουμε ότι η βέλτιστη λύση δεν περιλαμβάνει τη βέλτιστη λύση για τους διακομιστές $j$ έως $K$, αλλά μία άλλη λύση με κόστος $Q > JS[ j ]$. Τότε θα είναι:

\begin{align*}
            & J'[ i ] = Q + \sum_{l=i}^j{(j - l)B[l]}\\
\Rightarrow & J'[ i ] > J[ i ]
\end{align*}

Αυτό όμως είναι αδύνατο διότι η $J[ i ]$ είναι βέλτιστη. Άρα $Q = JS[ j ]$ και $J[ i ] = J'[ i ]$.

Χρησιμοποιώντας τη μαθηματική επαγωγή, αυτό ολοκληρώνει την απόδειξη.

\end{proof}

Επιπλέον, αποθηκεύοντας τους διακομιστές σε έναν πίνακα $W$ μπορούμε να κατασκευάσουμε τη λύση\footnote{Η υλοποίηση χρησιμοποιώντας τον πίνακα $W$ για ανακατασκευή του αποτελέσματος, καθώς και οι λύσεις όλων των υπόλοιπων προβλημάτων στη γλώσσα \selectlanguage{english}C \selectlanguage{greek} υπάρχουν στο \selectlanguage{english}\url{http://github.com/dionyziz/ntua-algo}\selectlanguage{greek}.}.

Αυτό μας επιτρέπει να κάνουμε μία επιπλέον βελτιστοποίηση, καθώς ένας διακομιστής πιο κοντά στην αρχή δεν μπορεί ποτέ να οδηγήσει στο να αποφευχθεί μία αποθήκευση που από επόμενο διακομιστή θεωρήθηκε βέλτιστη σε πρωτύτερους υπολογισμούς.

\selectlanguage{english}
\begin{algorithm}[H]
\caption{\textgreek{Άσκηση 5}}
\begin{algorithmic}[1]
\Procedure{Servers}{$b, c, n$}
	\State $\Omega \gets \{ i: b[ i ] > 0 \}$
	\If {$\Omega = \emptyset$}
		\State \Return $\emptyset$
	\EndIf
	\State $K \gets \max( \Omega )$
	\State $JS[ K ] \gets c[ K ]$
	\State $J[ K ] \gets c[ K ]$
	\State $W[ K ] \gets K$
	\For {$i \gets K - 1$ downto $1$}
		\State $JS[ i ] \gets J[ i + 1 ] + C[ i ]$
		\State $J[ i ] \gets \infty$
		\For {$j \gets i$ to $W[ i + 1 ]$}
			\State $cost \gets JS[ j ]$
			\For {$l = i$ to $j$}
				\State $cost \gets cost + ( j - l )B[ l ]$
				\If {$cost >= J[ i ]$}
					\State $break$
				\EndIf
			\EndFor
			\If {$cost < J[ i ]$}
				\State $J[ i ] \gets cost$
				\State $W[ i ] \gets j$
			\EndIf
		\EndFor
	\EndFor
	\State $S \gets \{ S_K \}$
	\State $i \gets W[ 1 ] + 1$
	\While {$i \leq K$}
		\State $S \gets S \cup \{ S_{i - 1} \}$
		\State $i \gets W[ i ] + 1$
	\EndWhile
	\State \Return S
\EndProcedure
\end{algorithmic}
\end{algorithm}
\selectlanguage{greek}

Ο αλγόριθμος θα είναι $O( n^3 )$ καθώς για κάθε διακομιστή υπολογίζεται το κόστος $JS$ και $J$ σε αυτόν, κάτι το οποίο χρειάζεται χρόνο $O( n^2 )$ για να ελεγχθούν όλοι οι πιθανοί επόμενοι διακομιστές, αφού για κάθε έλεγχο απαιτείται ο υπολογισμός ενός αθροίσματος.

\section*{Άσκηση 6}
\subsection*{α)}
\subsection*{β)}
\subsection*{γ)}

\end{document}
